import os
import os.path as osp

import matplotlib.pyplot as plt
import matplotlib as mpl
from matplotlib.ticker import MultipleLocator


def generate_filename(algorithm_name):
    """Generates the base name of the file containing a given graph. The files are saved on the graphs/ folder having
    with the algorithm name."""

    graphs_dir = osp.join(os.getcwd(), 'graphs')
    if not os.path.isdir(graphs_dir):
        os.mkdir(graphs_dir)

    return osp.join(graphs_dir, algorithm_name)


def setup_mpl(font_size=15):
    """Setup of font and draw area sizes."""
    mpl.rcParams['font.size'] = font_size
    mpl.rcParams['axes.labelsize'] = 15
    mpl.rcParams['axes.labelpad'] = 10

    plt.gcf().set_size_inches(7.2, 7.2)


def post_plotting_design():
    """Adds legends, pads axes label, soften grid color."""

    leg = plt.legend(fancybox=True, title=r'$\bf{Algoritmo}$')

    # set the linewidth of each legend object
    for legobj in leg.legendHandles:
        legobj.set_linewidth(2.0)

    # Forcing matplotlib to start the axes at (0,0)
    plt.ylim(ymin=0)
    #plt.ylim(ymin=0, ymax=209)
    plt.ylim(ymin=0)
    plt.xlim(xmin=0)

    plt.xlabel('Tamanho da entrada')
    plt.ylabel('Tempo (s)')

    # Making x-grid [10000,20000,...]
    # plt.axes().xaxis.set_major_locator(MultipleLocator(10000))
    # plt.axes().xaxis.set_minor_locator(MultipleLocator(5000))

    # plt.axes().yaxis.set_major_locator(MultipleLocator(20))

    plt.grid(True, color=(0.9, 0.9, 0.9))
    plt.grid(True, which='minor', color=(0.9, 0.9, 0.9))


def save_plot(gcf, name):
    filename = generate_filename(name)
    gcf.savefig('{}.eps'.format(filename), format='eps', dpi=1000)
    gcf.savefig('{}.png'.format(filename), format='png')


def plot(name, stats):
    """Given the statistics dict generated by the assemble_data code, plots a graph (input_size vs execution_time) and
    saves it as graphs/algorithm_name.{eps,png}."""
    # by the project design, all executions are under the same dataset, so fetching from a single one should be fine.
    x = stats['r']['size']

    if stats.get('a', None):
        lenx = len(stats['a']['size'])
    else:
        lenx = len(x)

    # getting the execution times.
    y_random = stats['r']['average_time'] if 'r' in stats else []
    y_asc = stats['a']['average_time'] if 'a' in stats else []
    y_desc = stats['d']['average_time'] if 'd' in stats else []

    setup_mpl()

    plt.plot(x[:lenx], y_random[:lenx], label='Embaralhado', color='#279427')
    if y_asc:
        # plt.plot(x, y_asc, label='Crescente', linewidth=3, color='#1C6CAA')
        plt.plot(x[:lenx], y_asc[:lenx], label='Crescente', color='#1C6CAA')

    if y_desc:
        plt.plot(x[:lenx], y_desc[:lenx], label='Decrescente', color='#FF7311')

    post_plotting_design()

    gcf = plt.gcf()
    save_plot(gcf, name)

    gcf.clear()


def plot_many_vs_many(algorithms, filename, mapping={}, dashed_lines=False):

    def get_presenting_details(mapping, algorithm):
        entry = mapping.get(algorithm, {})

        # None color means random color
        return entry.get('name', algorithm), entry.get('color', None)


    setup_mpl(font_size=12)
    for algorithm, statistics in algorithms.items():
        name, color = get_presenting_details(mapping, algorithm)
        if dashed_lines:
            plt.plot(statistics['size'], statistics['average_time'], label=name, color=color, dashes=[2,2])
        else:
            plt.plot(statistics['size'], statistics['average_time'], label=name, color=color)

    post_plotting_design()

    gcf = plt.gcf()
    save_plot(gcf, filename)

    gcf.clear()


def plot_a_vs_b(quick, iquick):
    x = quick['r']['size']

    y1 = quick['r']['average_time']
    y2 = iquick['r']['average_time']

    setup_mpl()
    plt.plot(x, y1, label='Recursivo', color='#af3190')
    plt.plot(x, y2, label='Iterativo', color='#31afa8')

    post_plotting_design()

    fig = plt.gcf()

    filename = generate_filename('quick_iquick')
    fig.savefig('{}.eps'.format(filename), format='eps', dpi=1000)
    fig.savefig('{}.png'.format(filename), format='png')
    fig.clear()
